# Байесовская фильтрация.

Байесовская фильтрация — это метод оценки состояния динамической системы на основе наблюдений, который использует [[Совместная и условная вероятность. Формула Байеса. Пример.|теорему Байеса]]. Этот метод часто применяется в задачах слежения и оценки, таких как [[Фильтр Калмана. Расширенный фильтр Калмана.|фильтрация Калмана]] и [[Фильтр частиц.|фильтрация частиц]]. Рассмотрим основные концепции и формулы Байесовской фильтрации.

### Основные концепции

В Байесовской фильтрации состояние системы в момент времени $t$ обозначается как $x_t$, а наблюдения — как $z_t$. Процесс можно описать двумя основными уравнениями:

1. **Модель перехода:** описывает, как состояние системы изменяется со временем.
   $p(x_t | x_{t-1})$

2. **Модель наблюдения:** описывает, как наблюдения связаны с состоянием системы.
   $p(z_t | x_t)$

### Предсказание

На этапе предсказания вычисляется [[Распределение случайной величины|априорное распределение состояния]] на основе предыдущего состояния:

$p(x_t | z_{1:t-1}) = \int p(x_t | x_{t-1}) p(x_{t-1} | z_{1:t-1}) \, dx_{t-1}$

### Обновление

На этапе обновления это априорное [[Распределение случайной величины|распределение]] комбинируется с новой наблюдаемой информацией для получения апостериорного распределения:

$p(x_t | z_{1:t}) = \dfrac{p(z_t | x_t) p(x_t | z_{1:t-1})}{p(z_t | z_{1:t-1})}$

где нормализующий множитель $p(z_t | z_{1:t-1})$ определяется как:

$p(z_t | z_{1:t-1}) = \int p(z_t | x_t) p(x_t | z_{1:t-1}) \, dx_t$

### Пример: Фильтр Калмана

[[Фильтр Калмана. Расширенный фильтр Калмана.|Фильтр Калмана]] — это специальный случай Байесовской фильтрации для линейных систем с гауссовским шумом. В этом случае все распределения являются гауссовскими, и вычисления могут быть выполнены аналитически. 

1. **Предсказание состояния:**
   
   $\hat{x}_t^- = A \hat{x}_{t-1} + B u_{t-1}$
   
   $P_t^- = A P_{t-1} A^T + Q$

2. **Обновление состояния:**
   
   $K_t = P_t^- H^T (H P_t^- H^T + R)^{-1}$
   
   $\hat{x}_t = \hat{x}_t^- + K_t (z_t - H \hat{x}_t^-)$
   
   $P_t = (I - K_t H) P_t^-$

где $A$ — матрица перехода состояния, $B$ — матрица управления, $u_{t-1}$ — вектор управления, $Q$ — ковариационная матрица шума процесса, $H$ — матрица наблюдения, $R$ — ковариационная матрица шума наблюдений, $\hat{x}_t$ — оценка состояния, $P_t$ — ковариационная матрица ошибки оценки, $K_t$ — матрица Калмана, $z_t$ — наблюдение.

Таким образом, Байесовская фильтрация предоставляет мощный и гибкий способ для оценки состояния системы на основе последовательных наблюдений и применения теоремы Байеса.

```python
import numpy as np

class BayesFilter:
    def __init__(self, initial_belief, motion_model, sensor_model):
        """
        Инициализация Байесовского фильтра.
        
        :param initial_belief: начальное распределение вероятностей (np.array)
        :param motion_model: функция модели движения
        :param sensor_model: функция модели сенсора
        """
        self.belief = initial_belief
        self.motion_model = motion_model
        self.sensor_model = sensor_model

    def predict(self, control):
        """
        Прогнозирование следующего состояния на основе управляющего воздействия.
        
        :param control: управляющее воздействие (например, движение робота)
        """
        self.belief = self.motion_model(self.belief, control)
        self.normalize_belief()

    def update(self, measurement):
        """
        Обновление распределения вероятностей на основе измерения.
        
        :param measurement: текущее измерение
        """
        self.belief = self.sensor_model(self.belief, measurement)
        self.normalize_belief()

    def normalize_belief(self):
        """
        Нормализация распределения вероятностей, чтобы их сумма была равна 1.
        """
        self.belief /= np.sum(self.belief)

    def get_belief(self):
        """
        Получение текущего распределения вероятностей.
        
        :return: текущее распределение вероятностей (np.array)
        """
        return self.belief

# Пример моделей для фильтра

def motion_model(belief, control):
    """
    Модель движения робота.
    
    :param belief: текущее распределение вероятностей (np.array)
    :param control: управляющее воздействие (например, движение робота)
    :return: обновленное распределение вероятностей (np.array)
    """
    new_belief = np.roll(belief, control)
    return new_belief

def sensor_model(belief, measurement):
    """
    Модель сенсора робота.
    
    :param belief: текущее распределение вероятностей (np.array)
    :param measurement: текущее измерение
    :return: обновленное распределение вероятностей (np.array)
    """
    # Пример: датчик имеет равномерное распределение вероятностей вокруг измерения
    likelihood = np.zeros_like(belief)
    likelihood[measurement] = 1.0
    return belief * likelihood

# Пример использования

if __name__ == "__main__":
    # Начальное распределение вероятностей
    initial_belief = np.array([0.2, 0.2, 0.2, 0.2, 0.2])

    # Создание объекта Байесовского фильтра
    bayes_filter = BayesFilter(initial_belief, motion_model, sensor_model)

    # Прогноз на основе управляющего воздействия (движение на 1 позицию вправо)
    bayes_filter.predict(control=1)
    print("После прогноза:", bayes_filter.get_belief())

    # Обновление на основе измерения (датчик указывает на позицию 2)
    bayes_filter.update(measurement=2)
    print("После обновления:", bayes_filter.get_belief())
```

### Объяснение

1. **Класс `BayesFilter`**: Этот класс инкапсулирует функциональность байесовской фильтрации. Он содержит методы `predict`, `update`, и `normalize_belief`.

2. **Метод `predict`**: Этот метод использует модель движения для обновления распределения вероятностей на основе управляющего воздействия.

3. **Метод `update`**: Этот метод обновляет распределение вероятностей на основе нового измерения.

4. **Метод `normalize_belief`**: Этот метод нормализует распределение вероятностей, чтобы их сумма была равна 1.

5. **Функции `motion_model` и `sensor_model`**: Примерные модели движения и сенсора. В реальных приложениях они могут быть гораздо сложнее.

6. **Пример использования**: Инициализация фильтра, выполнение прогноза и обновления на основе данных.