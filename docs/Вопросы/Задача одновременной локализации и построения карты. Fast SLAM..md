# Задача одновременной локализации и построения карты. Fast SLAM.

**astSlam** — один из подходов решения задач [SLAM](https://ru.wikipedia.org/wiki/SLAM_(%D0%BC%D0%B5%D1%82%D0%BE%D0%B4) "SLAM (метод)") ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") Simultaneous Localization And Mapping). В основе алгоритма лежит так называемый [фильтр частиц](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D1%87%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D1%82%D1%80 "Многочастичный фильтр") и применение [Байесовской сети](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B9%D0%B5%D1%81%D0%BE%D0%B2%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C "Байесовская сеть"). В FastSLAM одна большая карта рассматривается как совокупность локальных подкарт, что позволяет убрать зависимость ориентиров друг от друга и таким образом значительно сократить время пересчета оценки состояния системы[[1]](https://ru.wikipedia.org/wiki/FastSLAM#cite_note-1). Метод был разработан в 2002 году студентами Карнеги — Меллона и Стэнфордского университетов.

Вот подробное объяснение работы FastSLAM и пример реализации на Python с использованием объектно-ориентированного программирования (ООП):

### Основные компоненты FastSLAM

1. **Частицы (Particles)**: Набор гипотез о возможных состояниях робота (местоположении и ориентации).
2. **Фильтр Калмана (Kalman Filter)**: Используется для обновления оценки местоположения и карты для каждой частицы.
3. **Вес частицы (Particle Weight)**: Оценивает, насколько хорошо частица соответствует наблюдениям.

### Основные шаги алгоритма FastSLAM

1. **Инициализация**: Создание начального набора частиц с равномерным весом.
2. **Предсказание (Prediction)**: Применение модели движения к каждой частице для получения предсказанного состояния.
3. **Обновление (Update)**: Обновление состояния частиц на основе наблюдений с использованием фильтра Калмана.
4. **Пересэмплинг (Resampling)**: Выбор новых частиц на основе их весов для устранения частиц с малым весом и размножения частиц с большим весом.

### Пример реализации на Python

#### 1. Определение классов

```python
import numpy as np

class Particle:
    def __init__(self, x, y, theta, weight):
        self.x = x
        self.y = y
        self.theta = theta
        self.weight = weight
        self.landmarks = {}  # key: landmark id, value: [mean, covariance]

    def move(self, delta_x, delta_y, delta_theta):
        self.x += delta_x
        self.y += delta_y
        self.theta += delta_theta

    def update_landmark(self, landmark_id, z, R):
        if landmark_id not in self.landmarks:
            self.landmarks[landmark_id] = [z, R]
        else:
            mean, covariance = self.landmarks[landmark_id]

            # Фильтр Калмана: прогноз
            predicted_mean = mean
            predicted_covariance = covariance + R

            # Фильтр Калмана: обновление
            innovation = z - predicted_mean
            innovation_covariance = predicted_covariance + R

            kalman_gain = np.dot(predicted_covariance, np.linalg.inv(innovation_covariance))
            new_mean = predicted_mean + np.dot(kalman_gain, innovation)
            new_covariance = np.dot(np.eye(2) - kalman_gain, predicted_covariance)

            self.landmarks[landmark_id] = [new_mean, new_covariance]

class FastSLAM:
    def __init__(self, num_particles):
        self.particles = [Particle(np.random.uniform(-1, 1), 
                                   np.random.uniform(-1, 1), 
                                   np.random.uniform(-np.pi, np.pi), 
                                   1.0/num_particles) for _ in range(num_particles)]

    def predict(self, control):
        for particle in self.particles:
            delta_x, delta_y, delta_theta = control
            particle.move(delta_x, delta_y, delta_theta)

    def update(self, observations):
        for particle in self.particles:
            for obs in observations:
                landmark_id, obs_x, obs_y = obs
                z = np.array([obs_x, obs_y])
                R = np.array([[0.1, 0], [0, 0.1]])  # Допущение: одинаковая ковариация для всех измерений
                particle.update_landmark(landmark_id, z, R)

                # Обновление веса частицы
                mean, covariance = particle.landmarks[landmark_id]
                innovation = z - mean
                innovation_covariance = covariance + R

                weight = np.exp(-0.5 * np.dot(np.dot(innovation.T, np.linalg.inv(innovation_covariance)), innovation))
                particle.weight *= weight

        # Нормализация весов частиц
        total_weight = sum(particle.weight for particle in self.particles)
        for particle in self.particles:
            particle.weight /= total_weight

    def resample(self):
        weights = [particle.weight for particle in self.particles]
        new_particles_indices = np.random.choice(len(self.particles), size=len(self.particles), p=weights)
        self.particles = [self.particles[i] for i in new_particles_indices]

    def get_best_particle(self):
        best_particle = max(self.particles, key=lambda p: p.weight)
        return best_particle

# Пример использования:
num_particles = 100
fast_slam = FastSLAM(num_particles)

# Пример команд управления (delta_x, delta_y, delta_theta)
control = (0.1, 0.0, 0.05)
fast_slam.predict(control)

# Пример наблюдений [(id_landmark, x_obs, y_obs)]
observations = [(1, 2.0, 1.0), (2, -1.0, 3.0)]
fast_slam.update(observations)

# Пересэмплинг
fast_slam.resample()

# Получение наилучшей частицы
best_particle = fast_slam.get_best_particle()
print(f"Best particle: x={best_particle.x}, y={best_particle.y}, theta={best_particle.theta}, weight={best_particle.weight}")
```

### Объяснение примера

1. **Класс `Particle`**: Представляет частицу с положением (x, y, theta) и весом. Метод `move` обновляет положение частицы на основе модели движения.

2. **Класс `FastSLAM`**: Содержит набор частиц и методы для выполнения основных шагов алгоритма.
    - `__init__`: Инициализация набора частиц с случайным начальным положением.
    - `predict`: Применяет команду управления к каждой частице.
    - `update`: Обновляет вес каждой частицы на основе наблюдений.
    - `resample`: Пересэмплинг частиц на основе их весов.
    - `get_best_particle`: Возвращает частицу с наибольшим весом.

Этот пример показывает базовую структуру алгоритма FastSLAM. В реальной реализации обновление состояния частиц с использованием фильтра Калмана и работа с наблюдениями будет более сложной и требует точных математических вычислений.